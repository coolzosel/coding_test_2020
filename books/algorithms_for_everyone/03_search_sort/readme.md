# 탐색과 정렬
## 순차 탐색 (Sequential search; 선형 탐색; linear search)
> 순서가 있는 반복 가능한 객체 (리스트, 배열 등) 안에 있는 원소를 하나씩 순차적으로 비교하면서 탐색
- 위치를 의미하는 인덱스(index)는 0부터 시작하는 것을 유의
- 순차 탐색 알고리즘은 찾는 값의 위치에 따라 복잡도가 변동 (최악의 경우 모든 원소를 탐색하는 O(n))
## 정렬 (sort)
> 자료를 크기 순서대로 맞춰 일렬로 나열하는 것 (ex. 가나다순 혹은 알파벳순으로 단어를 나열한 사전)
> *주어진 배열 안의 자료를 작은 수부터 큰 수 순서로 배열하는 정렬 알고리즘을 만들어 보시오*
* 쉽게 설명한 정렬 알고리즘 : 정렬 원리를 이해하기 위한 효율성을 고려하지 않은 프로그램
* 일반적인 정렬 알고리즘 : 정식으로 구현한 프로그램
### 선택 정렬 (Selection sort)
* **동작 원리** : 남은 자료 중에 최솟값을 뽑아 차례로 배치
* **로직**
  * 0번째부터 n번째까지 중에서 최솟값을 찾는다
  * 0번째와 최솟값을 바꿔준다
  * 1번째부터 n번째까지 중에서 최솟값을 찾는다... (반복)
  * n-1번째와 n번째 중 최솟값을 앞에 위치해주고 끝남
* **계산 복잡도**
  * 비교 횟수는 n(n-1)/2, 즉 시간 복잡도 O(n<sup>2</sup>) 알고리즘
  * 입력 크기가 커질 수록 정렬에 시간이 굉장히 오래 걸림
### 삽입 정렬 (Insertion sort)
* **동작 원리** : 자료를 하나씩 적절한 위치에 삽입
* **로직**
  * 0번째가 삽입된다
  * 1번째가 0번째와 비교되어 작은 쪽으로 들어간다
  * 2번째가 1번째부터 0번째까지와 비교되어 적절한 위치로 들어간다 ... (반복)
  * n번째가 n-1번째부터 0번째까지와 비교되어 적절한 위치로 들어가며 끝남
* **계산 복잡도**
  * O(n<sup>2</sup>) 알고리즘 (선택 정렬과 유사)
  * 입력 크기가 커질 수록 정렬에 시간이 굉장히 오래 걸림
### 병합 정렬 (Merge sort)
* **동작 원리** : 그룹 나누기 → 그룹별로 각각 정렬(재귀 호출) → 병합
* **로직**
  * 그룹을 둘로 나눈다
  * 각각 그룹을 재귀 호출한다 (계속 반으로 쪼갬)
  * 원소가 하나 남을 때까지 (종료 조건)
  * 합칠 때마다 작은 것이 앞에 오게 하다 보면 정렬됨
* **재귀 호출의 세 가지 요건**
  1. 함수 안에서 자기 자신을 다시 호출
  2. 재귀 호출할 때 인자로 주어지는 입력 크기가 작아짐
  3. 특정 종료 조건이 만족되면 재귀 호출을 종료함
* **분할 정복 (divide and conquer)**
  * 큰 문제를 작은 문제로 나눠서(분할하여) 푸는(정복하는) 방식 (in 알고리즘 설계 기법)
  * 분할 정복은 잘 활용하면 계산 복잡도가 더 낮은 효율적인 알고리즘을 만드는 데 도움이 됨
* **계산복잡도**
  * O(n · logn)으로 선택 정렬이나 삽입 정렬의 계산 복잡도 O(n<sup>2</sup>)보다 낮음
### 퀵 정렬 (Quick sort)
* **동작 원리** : 기준 선택 → 기준에 맞춰 그룹 나누기 → 그룹별로 각각 정렬 (재귀 호출)
* 병합 정렬과 유사하지만 기준을 정해서 두 그룹으로 나눈다는 게 다름
* **로직**
  * 기준을 정한다
  * 기준을 중심으로 그룹을 둘로 나눈다
  * 각각 그룹을 재귀 호출한다 (계속 반으로 쪼갬)
* **계산복잡도**
  * O(n · logn) (보통의 경우)
